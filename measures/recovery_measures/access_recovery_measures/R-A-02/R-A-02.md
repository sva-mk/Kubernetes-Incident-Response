# R-A-02 Access Recovery by Restoring ServiceAccounts

By using ServiceAccount tokens based on the TokenRequest API, only ServiceAccount tokens are automatically issued by the control plane, whose validity is tied to the existence of a pod. This allows for token rotation through the replacement of the associated pods [[The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)]. However, it remains possible to manually issue long-lived tokens, whose validity is tied only to the existence of the ServiceAccount and the corresponding validity period [[The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)]. If, during an incident, it is discovered that attackers have created a long-lived token for an existing ServiceAccount, it is recommended to remove it according to the [E-A-01](/measures/eradication_measures/access_eradication_measures/E-A-01/E-A-01.md) method during the eradication phase and then restore the ServiceAccount. This ensures that all manually created ServiceAccount tokens are invalidated, while still allowing long-term use of the application [[The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)]. Based on this, access to the Kubernetes API via a previously removed ServiceAccount can be restored using the following procedure:

1. Create a ServiceAccount, including the assignment of permissions (see Listing 1 line 1) [[The23i](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/); [The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)].
   - An exemplary ServiceAccount with the corresponding role assignment can be found in Listing 2.
   - By default, ServiceAccounts do not receive any permissions, so the necessary permissions for the respective application must be assigned separately [[The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)]. For example, the ServiceAccount from Listing 2 is granted the necessary permissions to read all pods in the default namespace. Specifically, the role `default-pod-reader` is created and assigned to the ServiceAccount.

2. Create a persistent ServiceAccount token (see Listing 1 lines 2 to 13) [[The23i](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/); [The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)].
   - Depending on the need, the ServiceAccount token can be assigned an individual validity period.
   - Additionally, the token’s validity can be tied to specific pods or nodes in order to minimize the impact of a ServiceAccount token compromise [[The23i](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)].

3. Verify the ServiceAccount configuration (see Listing 1 line 14) [[The24o](https://kubernetes.io/docs/tasks/access-application-cluster/access-cluster/)].
   - Here, it is checked whether authentication with the configured ServiceAccount against the Kubernetes API is possible.

##### Listing 1: Commands for restoring ServiceAccounts according to [[The23i](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/); [The23ab](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/); [The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)]

```bash
kubectl apply -f ServiceAccount.yaml
kubectl apply -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
    name: <token-name>
    namespace: <namespace>
    annotations:
        kubernetes.io/service-account.name: <serviceaccount-name>
type: kubernetes.io/service-account-token
data:
    expirationSeconds: $(echo "60*60*24*365*2" | bc | base64)
EOF
curl -H "Authorization: Bearer $(kubectl get secret <token-name> -o=jsonpath=’{.data.token}’ -n <namespace> | base64 --decode)" https://<node-ip>:6443/api/v1/namespaces/<namespace>/pods --insecure -s -o /dev/null -w "%{http_code}\n"
```

##### Listing 2:   Exemplary YAML configuration for defining a service account according to [[The23i](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/); [The23ao](https://kubernetes.io/docs/concepts/security/service-accounts/)].
```bash
apiVersion: v1
kind: ServiceAccount
metadata:
  name: testapp-account
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: default
  name: default-pod-reader
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: default-pod-reader-role-binding
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: default-pod-reader
subjects:
- kind: ServiceAccount
  name: testapp-accoun
```


## Evaluation

The following table, entitled *Evaluation of measure R-A-02*, provides an overview of the evaluation of the aforementioned measure. The composition of the overall rating is then described in detail.

#### Table: Evaluation of R-A-02

| Criteria           | Result |
| ------------------ | ------ |
| Applicability      | 5      |
| Preparation Effort | 5      |
| Complexity         | 4      |
| Coverage           | 1      |
| Business Impact    | 5      |
| Visibility         | 5      |
| Resilience         | 1      |
| Reproducibility    | 5      |
| Interoperability   | 3      |
| Overall Rating     | 4,00   |

The measure was evaluated by implementing the exemplary configuration of a ServiceAccount, including the associated role assignment from Listing 2, in the experimental environment according to the aforementioned instructions. In the process, a very high applicability (5) and reproducibility (5) were observed, as the measure was successfully performed with identical results in all test scenarios. However, the interoperability of the results can only be rated as satisfactory (3), since only a text-based command-line output is possible within the described approach, though it serves its purpose well.

The preparation effort for the measure is very low (5), as all actions can be carried out using the Kubernetes API and typical command-line tools, meaning that only the identification of the ServiceAccounts to be restored needs to be done in advance. Similarly, the business impact and visibility of the measure are very low (5), as the operational state is not affected by the individual steps, and no compromised system components are altered. At the same time, the measure has low complexity (4), as it requires only three actions that demand minimal expertise. However, the coverage of the measure is very low (1), as removing and restoring ServiceAccounts only addresses the persistence of attackers (T1136). Furthermore, the resilience of the measure is also very low (1), as the ServiceAccount tokens of the new ServiceAccounts can be easily read if the compromise persists. Overall, the measure was still rated with a good overall score (4.00).

##### Figure 1: Business impact of measure R-A-02
![Business impact of measure R-A-02](Dependency-Modeling-Diagram_R-A-02.png)